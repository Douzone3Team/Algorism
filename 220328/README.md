# 그래프 탐색 알고리즘: DFS / BFS
+ 탐색(Search)이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말한다.
+ 대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있다.
+ DFS / BFS는 코딩 테스트에서 매우 자주 등장하는 유형이다.

<!-- ## 스택 자료구조
+ 먼저 들어 온 데이터가 나중에 나가는 형식(LIFO : 선입 후출)의 자료구조 입니다.
+ 입구와 출구가 동일한 형태로 스택을 시각화할 수 있다.

```python
stack = []

stack.append(5)
stack.append(2)
stack.append(4)
stack.append(3)
stack.pop()

print(stack[::-1]) #최상단 원소부터 출력
print(stack) #최하단 원소부터 출력
```

실행결과
```
[4,2,5]
[5,2,4]
```

## 큐 자료구조
+ 먼저 들어 온 데이터가 먼저 나가는 형식(FIFO : 선입선출)의 자료구조 입니다.
+ 큐는 입구와 출구가 모두 뚫려 있는 터널과 같은 형태로 시각화 할 수 있습니다.
 -->

## DFS(Depth-First Search,깊이 우선 탐색)

루트 노드(혹은 다른 임의의 노드)에서 다음 분기(branch)로 넘어가기 전에, 해당 분기(branch)를 모두 탐색하는 방법. 탐색 후에는 다시 원점으로 돌아가 다른 분기를 탐색합니다.


### 특징
* 자기 자신을 호출하는 순환 알고리즘의 형태를 지닌다.(재귀 or 스택)
* 이 알고리즘을 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야한다.
* 모든 노드를 방문하고자 할 때, 사용하는 방식
* 너비우선탐색(BFS)보다 더 간단하다.
* 검색속도 자체는 너비우선탐색(BFS)에 비해서 느리다.

### 과정

![image](https://user-images.githubusercontent.com/74586766/160378982-58cf2486-863d-403d-8616-5e79478c506a.png)

### 코드

```java
  // dfs, 재귀, 인접 행렬, i 정점부터 시작한다.
  public static void dfs(int i) {
      visit[i] = true;
      System.out.print(i + " ");
      for(int j=1; j<n+1; j++) {
          if(map[i][j] == 1 && visit[j] == false) {
              dfs(j);
          }
      }
  }
```

## BFS(Bread-First Search, 너비 우선 탐색)

루트 노드(혹은 다른 임의의 노드)에서 시작한 인접 노드를 먼저 탐색하는 방법이다.

### 특징
+ BFS는 재귀적으로 동작하지 않습니다.
+ 이 알고리즘 또한, 구현할 때 가장 큰 차이점은 그래프 탐색의 경우 어떤 노드를 방문했었는지 여부를 반드시 검사해야 한다.
+ BFS는 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 큐를 사용한다.
+ 즉, 선입선출 원칙으로 탐색한다.
+ 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다.
+ 깊게(deep) 탐색하기 전에 넓게(width) 탐색한다.
+ 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 사용한다.
  + ex)지구 상에 존재하는 모든 친구관계를 그래프로 표현한 후 A와 B 사이에 존재하는 경로를 찾는 경우
    + DFS의 경우 - 모드 친구 관계를 다 살펴봐야 할지도 모른다.
    + BFS의 경우 - A와 가까운 관계부터 탐색한다.

### 과정
깊이가 1인 모든 노드를 방문하고 나서 그 다음에, 깊이가 2인 모든 노드를, 그 다음엔 깊이가 3인 모든 노드를 방문하는 식으로 계속 방문하다가 더 이상 방문할 곳이 없으면 탐색을 마칩니다.

![99960F405BD01A8D18](https://user-images.githubusercontent.com/74586766/160381300-560dad8a-7030-41e3-879c-d539b33fe361.png)

### 코드

```java
//bfs, queue사용, 인접행렬, i 정점부터 시작한다.
public static void bfs(int i)
    Queue<Integer> q = new LinkedList<>();
    q.offer(i);
    visit[i] = true;
    
    while(!q.isEmpty()) {
        int temp = q.poll();
        System.out.print(temp + " ");
        for(int j = 1; j < n + 1; j++) {
            if(map[temp][j] == 1 && visit[j] == false) {
                q.offer(j);
                visit[j] = true;
            }
        }
    }
}
```








